---
title: "RO-MAN 2020 Plots"
output:
  html_document:
    theme: readable
    code_folding: hide
    df_print: tibble
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
---

```{r message=FALSE, warning=FALSE}
library(car)
library(stats)
library(grid)
library(gridExtra)
library(fitdistrplus)
# library(dplyr)
# library(forcats)
# library(tibble)
# library(tidyr)
# library(readr)
# library(ggplot2)
# library(stringr)
library(tidyverse)
library(ggsignif)
library(ggthemes)
library(jtools)
library(broom)
library(modelr)
library(loo)
# library(rstanarm)
library(brms)
library(bayesplot)
library(tidybayes)
library(bayestestR)
library(sjstats)
library(report)
library(see)

# Setup for multiprocessing
options(mc.cores = 4)
# library(future)
# plan(multiprocess)

# Make the default coding of contrasts sum-coding; just in case
options(contrasts = c("contr.sum", "contr.poly"))
```

Global options:

```{r}
default_seed = 0x1331
data_folder = "~/Documents/GT/Research/Data/arbitration/2019-12-09/results"
```

Helper functions:

```{r, message=FALSE, warning=FALSE}
# Create a simple coding contrasts matrix
contr.deviation = function(nlevels) {
  x1 = contr.treatment(nlevels)
  x2 = matrix(rep(1/nlevels, (nlevels-1) * nlevels), ncol = (nlevels-1))
  return(x1-x2)
}

# NOTE: For now we're ignoring this advice
# # Use a simple coding contrasts matrix to add our own contrasts columns
# # Explained in: http://talklab.psy.gla.ac.uk/tvw/catpred/
# create_simple_contrasts = function(d, column_name) {
#  factor_column = d %>% pull(column_name)
#  contrast_matrix = contr.deviation(length(levels(factor_column)))
# }

# Save a model
saveModel = function(model, folder = data_folder) {
  saveRDS(model, file = file.path(folder, paste(substitute(model), ".rds", sep = '')))
}

# Load a model
loadModel = function(model_name, folder = data_folder) {
  return(readRDS(file.path(folder, paste(model_name, '.rds', sep = ''))))
}

# Test hypotheses. The NULL arguments need to be provided in this case
test_hypotheses = function(h_df = NULL, rope_values = NULL, hypotheses_list = NULL, model = NULL) {
  # Option 1: Use the hypothesis function in brms
  if (!is.null(hypotheses_list)) {
    hyp_results = hypothesis(model, hypothesis = hypotheses_list, seed = default_seed)
    return(hyp_results)
  }

  # Option 2: Use the ROPE & Overlap amount
  else {
    if (is.null(rope_values)) {
      rope_values = c(-0.1, 0.1)
    }
    hyp_results =
      h_df %>%
        equivalence_test(range = rope_values) %>%
        as_tibble() %>%
        bind_cols(h_df %>% pd() %>% select(pd))
    return(hyp_results)
  }
}

# Fit distributions to vectors and print the results. Also return the fit, if necessary
fit_and_print_dist = function(vec, distr, string) {
  f = fitdist(vec, distr)
  print(paste(string, f$loglik, f$aic))
  return(f)
}
```

Data loading:

```{r, message=F, warning=F}
# Load the CSV files. If the age_group fill model is run again and we get a different output,
# then remember to update the value here
loadCSV = function(filename, age_group_fill, contrast_func) {
  dat = read_csv(
    file.path(data_folder, filename),
    col_types = cols(
      study_condition = col_factor(),
      noise_level = col_factor(ordered = T),
      gender = col_factor(levels = c("F", "M", "U")),
      age_group = col_factor(levels = seq(from = 0, to = 8)),
      robot_experience = col_factor(levels = seq(from = 0, to = 4))
    )
  )

  # Relabel the factors
  dat = dat %>%
    mutate(study_condition = fct_recode(study_condition,
                                        BASELINE="1",
                                        DX_100="2", AX_100="3", DXAX_100="4",
                                        DX_90="5", AX_90="6", DXAX_90="7",
                                        DX_80="8", AX_80="9", DXAX_80="10")) %>%
    mutate(study_condition = fct_relevel(study_condition, c("DX_100", "AX_100", "DXAX_100",
                                                            "DX_90", "AX_90", "DXAX_90",
                                                            "DX_80", "AX_80", "DXAX_80")))

  # Relevel the non-binary gender
  dat$gender[dat$gender == 'U'] = 'M'

  # Change binary responses to integers
  dat$scenario_completed = as.integer(dat$scenario_completed)
  
  # Relevel age_group
  dat[dat$age_group == 0,]$age_group = age_group_fill
  
  # Create an unordered noise_level. Also drop unused levels
  dat$age_group = droplevels(dat$age_group)
  dat$gender = droplevels(dat$gender)
  dat$noise_level_f = factor(dat$noise_level, ordered = F)

  # Set the contrasts for everything
  contrasts(dat$age_group) = contrast_func(length(levels(dat$age_group)))
  contrasts(dat$robot_experience) = contrast_func(length(levels(dat$robot_experience)))
  contrasts(dat$gender) = contrast_func(length(levels(dat$gender)))

  contrasts(dat$has_ax) = contrast_func(2)
  contrasts(dat$has_dx) = contrast_func(2)
  contrasts(dat$has_noise) = contrast_func(2)
  contrasts(dat$has_dxax) = contrast_func(2)

  contrasts(dat$noise_level_f) = contrast_func(length(levels(dat$noise_level_f)))
  
  # Return the data frame
  return(dat)
}

# Get the users df and the actions df
users = loadCSV("users.csv", 4, contr.sum)
actions = loadCSV("actions.csv", 4, contr.sum)

# Change more binary responses to integers
actions$optimal_ax = as.integer(actions$optimal_ax)
actions$chose_ax = as.integer(actions$chose_ax)
actions$optimal_dx = as.integer(actions$optimal_dx)
actions$chose_dx = as.integer(actions$optimal_dx)

# Relabel user ids to be in the range 1-200. Otherwise, we're using DB ids
# The user ID column in the users table that we can now join on is X1
actions$user_id = actions %>% group_indices(user_id)

# Rescale state ids
actions$state_idx_rescaled = scales::rescale(actions$state_idx)

# Code to relevel the age group factor to remove unused levels. Also, predict the
# value of the 1 unknown age from the other indicators of demographics
# NOTE: If we retrain the model and the output doesn't match the hardcoded
# values, then update those values
# if (train_models) {
#   plot_df = subset(users, users$age_group != 0)
#   plot_df$age_group = factor(plot_df$age_group, levels = seq(from = 0, to = 8), ordered = T)
#   plot_df$age_group = droplevels(plot_df$age_group)
#   age_group_model = brm(age_group ~ gender + robot_experience, data = plot_df, family = "cumulative")
#   data_to_predict = users %>% filter(age_group == 0) %>% select(c("robot_experience", "gender"))
#   as_tibble(predict(age_group_model, data_to_predict))
# # A tibble: 1 x 7
#   `P(Y = 2)` `P(Y = 3)` `P(Y = 4)` `P(Y = 5)` `P(Y = 6)` `P(Y = 7)` `P(Y = 8)`
#        <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl>
# 1     0.0838      0.202      0.215      0.188      0.110      0.089      0.111
#   rm(age_group_model)
# }
```

Use this notebook to generate the final plots from `iros2020.Rmd`.


# Scenario Completed

Load the data and the models:

```{r}
plot_df = users %>%
  select(X1, id, study_condition, start_condition, num_optimal,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed)

scenario_completed.model.t = loadModel("scenario_completed.model.t")
scenario_completed.model.v = loadModel("scenario_completed.model.v")
```

```{r, fig.width=3.5, fig.height=5}
gg_df = plot_df %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1")) %>%
  count(has_ax, has_dx, noise_level, scenario_completed) %>%
  mutate(has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

gg_df %>%
  ggplot(aes(has_ax, n / 20, fill=scenario_completed)) +
    geom_bar(stat = "identity") +
    facet_grid(rows = vars(noise_level), cols = vars(has_dx)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_y_continuous(breaks = c(0, 0.5, 1.0)) +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          legend.title = element_blank(),
          legend.position = "bottom",
          axis.title.y = element_blank())
```

Significance Results:

1. Medium positive effect of AX
1. Medium U-shaped effect of accuracy
1. Small positive effect of 100% accurate suggestions
1. Small negative effect of 90% accurate suggestions

So the related plots:


```{r, fig.width=3.5, fig.height=2.5}
eff = fixef(scenario_completed.model.v)

gg_df = plot_df %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1")) %>%
  count(has_ax, has_dx, noise_level, scenario_completed) %>%
  mutate(has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"),
         estimate = -1) %>%
  mutate(estimate = if_else(has_ax == "No AX", inv_logit_scaled(eff["Intercept", "Estimate"] + eff["has_ax1","Estimate"]), estimate)) %>%
  mutate(estimate = if_else(has_ax == "AX", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["has_ax1", "Estimate"]), estimate))

gg_df %>%
  filter(scenario_completed == 'Resolved') %>%
  ggplot(aes(has_ax, n/20, group = has_ax, colour = has_ax)) +
    geom_count() +
    geom_boxplot(aes(y = estimate)) +
    geom_signif(y_position = 1.05, xmin = 1, xmax = 2, annotation = "**", textsize = 8, color = "black") +
    scale_y_continuous(limits = c(0.5, 1.1)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, fig.width=3.5, fig.height=2.5}
eff = fixef(scenario_completed.model.v)

gg_df = plot_df %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1")) %>%
  count(has_ax, has_dx, noise_level, scenario_completed) %>%
  mutate(has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"),
         estimate = -1) %>%
  mutate(estimate = if_else(noise_level == "Acc: 100%", inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 90%", inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 80%", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]), estimate)) %>%
  mutate(noise_level = fct_rev(noise_level))

gg_df %>%
  filter(scenario_completed == 'Resolved') %>%
  ggplot(aes(noise_level, n/20, group = noise_level, colour = noise_level)) +
    geom_hline(yintercept = inv_logit_scaled(eff["Intercept", "Estimate"]),
               size = .7, linetype = "dashed", color = "grey") +
    geom_count() +
    geom_boxplot(aes(y = estimate)) +
    annotate("segment",
             x = 3,
             y = inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             colour = "black") +
    annotate("segment",
             x = 1,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             color = "black") +
    annotate("text",
             x = 3.5,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - 0.85),
             label = "Mean of all levels",
             angle = 90,
             group = NA,
             colour = "black") +
    scale_y_continuous(limits = c(0.5, 1.1), breaks = c(0.5, 1.0)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    scale_size_area(max_size = 1) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```


```{r, echo=F, results=F, message=F, warning=F}
rm(scenario_completed.model.t, scenario_completed.model.v)
gc()
```


# Num Actions Diff

Load the data and the models:

```{r}
plot_df = users %>%
  select(X1, id, study_condition, start_condition, num_optimal,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed, num_actions, num_actions_diff, frac_actions_diff) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

num_actions_diff.model.t = loadModel("num_actions_diff.model.t")
num_actions_diff.model.v = loadModel("num_actions_diff.model.v")
```

```{r, fig.width=7, fig.height=5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":"))

fit_df = fitdist(gg_df %>% filter(scenario_completed == "Resolved") %>% pull(num_actions_diff),
                 "nbinom")

gg_df %>%
  ggplot(aes(num_actions_diff, group = scenario_completed, fill = scenario_completed)) +
    geom_histogram(binwidth = 1) +
    stat_function(fun = function(z, size, mu)(dnbinom(z, size = size, mu = mu) * 200 * 1),
                  args = as.list(fit_df$estimate),
                  aes(colour = "Negative Binomial"),
                  n = 18) +
    xlab("Number of Unncessary Actions (UA)") +
    ylab("Number of Participants") +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          legend.position = "top",
          legend.title = element_blank())
```

Significance Results:

None

So the related plots:

```{r, echo=F, results=F, message=F, warning=F}
rm(num_actions_diff.model.t, num_actions_diff.model.v)
gc()
```


# Taking the Optimal Action for a State

Load the data and the models:

```{r}
plot_df = actions %>%
  select(X1, id, user_id, study_condition, start_condition, num_optimal,
         state_idx, state_idx_rescaled,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed, num_actions, optimal_ax) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

optimal_ax.model.t = loadModel("optimal_ax.model.t")
optimal_ax.model.v = loadModel("optimal_ax.model.v")
```

```{r, fig.width=3.5, fig.height=5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, optimal_ax, num_actions, has_ax, has_dx, noise_level,
        name = "num_optimal_ax")

gg_df %>%
  filter(optimal_ax == "1") %>%
  ggplot(aes(has_ax, num_optimal_ax / num_actions, fill=.fill_column)) +
    geom_boxplot() +
    # geom_count() +
    facet_grid(rows = vars(noise_level), cols = vars(has_dx)) +
    labs(y = NULL, x = NULL) +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

Significance Results:

1. Small positive effect of AX

So the related plots:

```{r, fig.width=3.5, fig.height=5}
eff = fixef(optimal_ax.model.v)

gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, optimal_ax, num_actions, has_ax, has_dx, noise_level,
        name = "num_optimal_ax") %>%
  mutate(estimate = -1) %>%
  mutate(estimate = if_else(has_ax == "No AX", inv_logit_scaled(eff["Intercept", "Estimate"] + eff["has_ax1","Estimate"]), estimate)) %>%
  mutate(estimate = if_else(has_ax == "AX", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["has_ax1", "Estimate"]), estimate))

gg_df %>%
  filter(optimal_ax == "1") %>%
  ggplot(aes(has_ax, num_optimal_ax / num_actions, group = has_ax, colour=has_ax)) +
    geom_count(aes(colour = NULL)) +
    geom_boxplot(aes(y = estimate)) +
    geom_signif(y_position = 1.07, xmin = 1, xmax = 2, annotation = "*", textsize = 8, color = "black") +
    scale_y_continuous(limits = c(0.0, 1.1), breaks = c(0.0, 0.5, 1.0)) +
    labs(y = NULL, x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, echo=F, results=F, message=F, warning=F}
rm(optimal_ax.model.t, optimal_ax.model.v)
gc()
```


# Choosing the Correct Diagnosis for a State

Load the data and the models:

```{r}
plot_df = actions %>%
  select(X1, id, user_id, study_condition, start_condition, num_optimal,
         state_idx, state_idx_rescaled,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed, num_actions, optimal_dx) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

optimal_dx.model.t = loadModel("optimal_dx.model.t")
optimal_dx.model.v = loadModel("optimal_dx.model.v")
```

```{r, fig.width=3.5, fig.height=5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, optimal_dx, num_actions, has_ax, has_dx, noise_level,
        name = "num_correct_dx")

gg_df %>%
  filter(optimal_dx == "1") %>%
  ggplot(aes(has_ax, num_correct_dx / num_actions, fill=.fill_column)) +
    geom_boxplot() +
    # geom_count() +
    facet_grid(rows = vars(noise_level), cols = vars(has_dx)) +
    labs(y = NULL, x = NULL) +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

Significance Results:

1. Small positive effect of DX
1. Insignificant linear effect of Noise

So the related plots:

```{r, fig.width=3.5, fig.height=2.5}
eff = fixef(optimal_dx.model.v)

gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, optimal_dx, num_actions, has_ax, has_dx, noise_level,
        name = "num_correct_dx") %>%
  mutate(estimate = -1) %>%
  mutate(estimate = if_else(has_dx == "No DX", inv_logit_scaled(eff["Intercept", "Estimate"] + eff["has_dx1","Estimate"]), estimate)) %>%
  mutate(estimate = if_else(has_dx == "DX", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["has_dx1", "Estimate"]), estimate))

gg_df %>%
  filter(optimal_dx == "1") %>%
  ggplot(aes(has_dx, num_correct_dx / num_actions, group = has_dx, colour=has_dx)) +
    geom_count(aes(colour = NULL)) +
    geom_boxplot(aes(y = estimate)) +
    geom_signif(y_position = 1.15, xmin = 1, xmax = 2, annotation = "*", textsize = 8, color = "black") +
    scale_y_continuous(limits = c(0.0, 1.25), breaks = c(0.0, 0.5, 1.0)) +
    labs(y = NULL, x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, fig.width=3.5, fig.height=2.5}
eff = fixef(optimal_dx.model.v)

gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, optimal_dx, num_actions, has_ax, has_dx, noise_level,
        name = "num_correct_dx") %>%
  mutate(estimate = -1) %>%
  mutate(estimate = if_else(noise_level == "Acc: 100%", inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 90%", inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 80%", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]), estimate)) %>%
  mutate(noise_level = fct_rev(noise_level))

gg_df %>%
  filter(optimal_dx == "1") %>%
  ggplot(aes(noise_level, num_correct_dx / num_actions, group = noise_level, colour = noise_level)) +
    geom_hline(yintercept = inv_logit_scaled(eff["Intercept", "Estimate"]),
               size = .7, linetype = "dashed", color = "grey") +
    geom_count() +
    geom_boxplot(aes(y = estimate)) +
    annotate("segment",
             x = 3,
             y = inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             colour = "black") +
    annotate("segment",
             x = 1,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             color = "black") +
    annotate("text",
             x = 3.5,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - 0.85),
             label = "Mean of all levels",
             angle = 90,
             group = NA,
             colour = "black") +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    scale_size_area(max_size = 1) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, echo=F, results=F, message=F, warning=F}
rm(optimal_dx.model.t, optimal_dx.model.v)
gc()
```


# Following Action Suggestions

Load the data and the models:

```{r}
plot_df = actions %>%
  filter(has_ax == T) %>%
  select(X1, id, user_id, study_condition, start_condition, num_optimal,
         state_idx, state_idx_rescaled,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed, num_actions, chose_ax) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

chose_ax.model.t = loadModel("chose_ax.model.t")
chose_ax.model.v = loadModel("chose_ax.model.v")
```

```{r, fig.width=3.5, fig.height=5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, chose_ax, num_actions, has_dx, noise_level,
        name = "num_chose_ax")

gg_df %>%
  filter(chose_ax == "1") %>%
  ggplot(aes(has_dx, num_chose_ax / num_actions, fill=.fill_column)) +
    geom_boxplot() +
    # geom_count() +
    facet_grid(rows = vars(noise_level)) +
    labs(y = NULL, x = NULL) +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

Significance Results:

1. Insignificant linear effect of noise

So the related plots:

```{r, fig.width=3.5, fig.height=5}
eff = fixef(chose_ax.model.v)

gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, chose_ax, num_actions, has_dx, noise_level,
        name = "num_chose_ax") %>%
  mutate(estimate = -1) %>%
  mutate(estimate = if_else(noise_level == "Acc: 100%", inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 90%", inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 80%", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]), estimate)) %>%
  mutate(noise_level = fct_rev(noise_level))

gg_df %>%
  filter(chose_ax == "1") %>%
  ggplot(aes(noise_level, num_chose_ax / num_actions, group = noise_level, colour = noise_level)) +
    geom_hline(yintercept = inv_logit_scaled(eff["Intercept", "Estimate"]),
               size = .7, linetype = "dashed", color = "grey") +
    geom_count() +
    geom_boxplot(aes(y = estimate)) +
    annotate("segment",
             x = 3,
             y = inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             colour = "black") +
    annotate("segment",
             x = 1,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             color = "black") +
    annotate("text",
             x = 3.5,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - 0.25),
             label = "Mean of all levels",
             angle = 90,
             group = NA,
             colour = "black") +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    scale_size_area(max_size = 1) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, echo=F, results=F, message=F, warning=F}
rm(chose_ax.model.t, chose_ax.model.v)
gc()
```


# Following Diagnosis Suggestions

Load the data and the models:

```{r}
plot_df = actions %>%
  filter(has_dx == T) %>%
  select(X1, id, user_id, study_condition, start_condition, num_optimal,
         state_idx, state_idx_rescaled,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         scenario_completed, num_actions, chose_dx) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

chose_dx.model.t = loadModel("chose_dx.model.t")
chose_dx.model.v = loadModel("chose_dx.model.v")
```

```{r, fig.width=3.5, fig.height=5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, chose_dx, num_actions, has_ax, noise_level,
        name = "num_chose_dx")

gg_df %>%
  filter(chose_dx == "1") %>%
  ggplot(aes(has_ax, num_chose_dx / num_actions, fill=.fill_column)) +
    geom_boxplot() +
    # geom_count() +
    facet_grid(rows = vars(noise_level)) +
    labs(y = NULL, x = NULL) +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

Significance Results:

1. Small linear effect of noise

So the related plots:

```{r, fig.width=3.5, fig.height=5}
eff = fixef(chose_dx.model.v)

gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  count(user_id, study_condition, .fill_column, chose_dx, num_actions, has_ax, noise_level,
        name = "num_chose_dx") %>%
  mutate(estimate = -1) %>%
  mutate(estimate = if_else(noise_level == "Acc: 100%", inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 90%", inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]), estimate)) %>%
  mutate(estimate = if_else(noise_level == "Acc: 80%", inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]), estimate)) %>%
  mutate(noise_level = fct_rev(noise_level))

gg_df %>%
  filter(chose_dx == "1") %>%
  ggplot(aes(noise_level, num_chose_dx / num_actions, group = noise_level, colour = noise_level)) +
    geom_hline(yintercept = inv_logit_scaled(eff["Intercept", "Estimate"]),
               size = .7, linetype = "dashed", color = "grey") +
    geom_count() +
    geom_boxplot(aes(y = estimate)) +
    annotate("segment",
             x = 3,
             y = inv_logit_scaled(eff["noise_level_f1","Estimate"] + eff["Intercept", "Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             colour = "black") +
    annotate("segment",
             x = 1,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - eff["noise_level_f1","Estimate"] - eff["noise_level_f2","Estimate"]),
             xend = 2,
             yend = inv_logit_scaled(eff["noise_level_f2","Estimate"] + eff["Intercept", "Estimate"]),
             color = "black") +
    annotate("text",
             x = 3.5,
             y = inv_logit_scaled(eff["Intercept", "Estimate"] - 0.25),
             label = "Mean of all levels",
             angle = 90,
             group = NA,
             colour = "black") +
    scale_y_continuous(limits = c(0.0, 1.0), breaks = c(0.0, 0.5, 1.0)) +
    labs(y = "Fraction of participants that resolved fault", x = NULL) +
    scale_colour_manual(values = c("#d62728", "#2ca02c", "#ff7f0e")) +
    scale_size_area(max_size = 1) +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank()) +
    legend_none()
```

```{r, echo=F, results=F, message=F, warning=F}
rm(chose_dx.model.t, chose_dx.model.v)
gc()
```


# SUS

Load the data and the models:

```{r}
plot_df = users %>%
  select(X1, id, study_condition, start_condition, num_optimal,
         age_group, gender, robot_experience,
         noise_level, noise_level_f, has_noise, has_dx, has_ax,
         sus, scenario_completed) %>%
  mutate(scenario_completed = factor(scenario_completed)) %>%
  mutate(scenario_completed = fct_recode(scenario_completed, Unresolved="0", Resolved = "1"),
         has_ax = fct_recode(has_ax, "No AX"="FALSE", "AX"="TRUE"),
         has_dx = fct_recode(has_dx, "No DX"="FALSE", "DX"="TRUE"),
         noise_level = fct_recode(noise_level, "Acc: 100%"="0.0", "Acc: 90%"="1.0", "Acc: 80%"="2.0"))

sus.model.t = loadModel("sus.model.t")
sus.model.v = loadModel("sus.model.v")
```

Significance Results:

None

So the related plots:

```{r, fig.width=5, fig.height=3.5}
gg_df = plot_df %>%
  mutate(.fill_column = paste(noise_level, !(study_condition == 'BASELINE'), sep = ":")) %>%
  mutate(study_condition = fct_rev(study_condition)) %>%
  group_by(study_condition, .fill_column) %>%
  summarise(mad = mad(sus), sus = median(sus))

gg_df %>%
  ggplot(aes(study_condition, sus, fill=.fill_column)) +
    # geom_boxplot() +
    geom_bar(stat = "identity") +
    geom_errorbar(aes(ymin = sus-mad, ymax = sus+mad), width = 0) +
    # coord_flip() +
    # facet_grid(rows = vars(noise_level), cols = vars(has_dx)) +
    labs(y = NULL, x = NULL) +
    scale_y_continuous(limits = c(0.0, 100.0), breaks = c(0.0, 50, 100)) +
    scale_x_discrete() +
    scale_fill_economist() +
    theme_economist_white(base_size = 13) +
    theme(plot.background = element_rect(fill = "white"),
          axis.title.y = element_blank(),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          panel.grid.major.y = element_blank()) +
    legend_none()
```

```{r, echo=F, results=F, message=F, warning=F}
rm(sus.model.t, sus.model.v)
gc()
```


# Demographics

TODO